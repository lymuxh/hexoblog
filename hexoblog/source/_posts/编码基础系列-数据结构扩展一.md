---
title: 编码基础系列-数据结构扩展一
date: 2019-03-26 17:50:11
tags: [数据结构,编程基础,树,广义表]
---

## 数组和广义表

数组和广义表可看成是一种特殊的线性表，其特殊在于: 表中的元素本身也是一种线性表。内存连续。根据下标在O(1)时间读/写任何元素。

二维数组，多维数组，广义表、树、图都属于非线性结构。

### 数组与关联数组

数组的存储顺序：
  1. 行优先顺序；
  2. 列优先顺序。

数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构。

关联数组(Associative Array)，又称映射（Map）、字典（ Dictionary）是一个抽象的数据结构，它包含着类似于(键，值)的有序对。 不是线性表。

<!-- more -->

矩阵的压缩：

对称矩阵、三角矩阵：直接存储矩阵的上三角或者下三角元素。注意区分i>=j和i<=j。

### 广义表

广义表（Lists，又称列表）是线性表的推广。广义表是n(n≥0)个元素a<sup>1</sup>,a<sup>2</sup>,a<sup>3</sup>,…,a<sup>n</sup>的有限序列，其中a<sup>i</sup>或者是原子项，或者是一个广义表。若广义表LS（n>=1)非空，则a<sup>1</sup>是LS的表头，其余元素组成的表(a<sup>2</sup>,…a<sup>n</sup>)称为LS的表尾。广义表的元素可以是广义表，也可以是原子，广义表的元素也可以为空。表尾是指除去表头后剩下的元素组成的表，表头可以为表或单元素值。所以表尾不可以是单个元素值。

例子：

A=（）——A是一个空表，其长度为零。
B=（a）——表B只有一个原子a，B的长度为1。
C=（a,(b,c,d))——表C的长度为2，两个元素分别为原子a和子表(b,c,d)。
D=（A，B，C）——表D的长度为3，三个元素都是广义 表。显然，将子表的值代入后，则有D=(( ),(a),(a,(b,c,d)))。
E=（a,E）——这是一个递归的表，它的长度为2，E相当于一个无限的广义表E=(a,(a,(a,(a,…))))。

三个结论：

* 广义表的元素可以是子表，而子表的元素还可以是子表。由此，广义表是一个多层次的结构，可以用图形象地表示

* 广义表可为其它表所共享。例如在上述例4中，广义表A，B，C为D的子表，则在D中可以不必列出子表的值，而是通过子表的名称来引用。

* 广义表的递归性

扩展：

* 广义表是0个或多个单因素或子表组成的有限序列，广义表可以是自身的子表，广义表的长度n>=0，所以可以为空表。广义表的同级元素(直属于同一个表中的各元素)具有线性关系。

* 广义表的表头为空，并不代表该广义表为空表。广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()。

* 已知广义表LS＝((a,b,c),(d,e,f)),运用head和tail函数取出LS中原子e的运算是head(tail(head(tail(LS)))。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。也就是说，广义表的head操作，取出的元素是什么，那么结果就是什么。但是tail操作取出的元素外必须加一个表——“（）“。tail(LS)＝((d,e,f))；head(tail(LS))=(d,e,f)；tail(head(tail(LS)))=(e,f)；head(tail(head(tail(LS))))=e。

* 二维以上的数组其实是一种特殊的广义表。

而在（非空）广义表中：

* 表头head可以是原子或者一个表 

* 表尾tail一定是一个表 

* 广义表难以用顺序存储结构 

* 广义表可以是一个多层次的结构

## 树和二叉树

一种非线性结构。树是递归结构，在树的定义中又用到了树的概念。

基本术语：

树结点：包含一个数据元素及若干指向子树的分支；

孩子结点：结点的子树的根称为该结点的孩子；

双亲结点：B结点是A结点的孩子，则A结点是B结点的双亲；

兄弟结点：同一双亲的孩子结点；

堂兄结点：同一层上结点；

结点层次：根结点的层定义为1；根的孩子为第二层结点，依此类推；

树的高（深）度：树中最大的结点层；

结点的度：结点子树的个数；

树的度： 树中最大的结点度；

叶子结点：也叫终端结点，是度为0的结点；

分枝结点：度不为0的结点（非终端结点）；

森林：互不相交的树集合；

有序树：子树有序的树，如：家族树；

无序树：不考虑子树的顺序；


### 二叉树

二叉树可以为空。二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别。注意区分：二叉树、二叉查找树/二叉排序树/二叉搜索树、二叉平衡(查找)树。

二叉平衡树肯定是一颗二叉排序树。堆不是一颗二叉平衡树。

二叉树与树是不同的，二叉树不等价于分支树最多为二的有序树。当一个结点只包含一个子节点时，对于有序树并无左右孩子之分，而对于二叉树来说依然有左右孩子之分，所以二叉树与树是两种不同的结构。

性质：

在二叉树的第 i 层上至多有2<sup>i-1</sup>个结点。

深度为 k 的二叉树上至多含 2<sup>k</sup>-1 个结点（k≥1）

对任何一棵二叉树，若它含有n<sub>0</sub>个叶子结点、n<sub>2</sub>个度为 2 的结点，则必存在关系式：n<sub>0</sub>= n<sub>2</sub>+1。

具有 n 个结点的完全二叉树的深度为⎣log<sub>2</sub> n⎦ + 1 。

n个结点的二叉树中，完全二叉树具有最小的路径长度。

如果对一棵有n个结点的完全二叉树的结点按层序编号,则对任一结点i（1<=i<=n),有： 

* 如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则其双亲d的编号是 i/2(整除）。

* 如果2i>n，无左孩子；否则，其左孩子是结点2i。

* 如果2i＋1>n，则结点i无右孩子；否则，其右孩子是结点2i＋1。

二叉树的存储结构

顺序存储结构：仅仅适用于满或完全二叉树，结点之间的层次关系由性质5确定。

二叉链表法：每个节点存储左子树和右子树。三叉链表：左子树、右子树、父节点，总的指针是n+2。

在有n个结点的二叉链表中，值为非空的链域的个数为n-1。在有N个结点的二叉链表中必定有2N个链域。除根结点外，其余N-1个结点都有一个父结点。所以，一共有N-1个非空链域，其余2N-(N-1)=N+1个为空链域。

二叉链存储法也叫孩子兄弟法，左指针指向左孩子，右指针指向右兄弟。而中序遍历的顺序是左孩子，根，右孩子。这种遍历顺序与存储结构不同，因此需要堆栈保存中间结果。而中序遍历检索二叉树时，由于其存储结构跟遍历顺序相符，因此不需要用堆栈。

### 遍历二叉树和线索二叉树

遍历二叉树：使得每一个结点均被访问一次，而且仅被访问一次。非递归的遍历实现要利用栈。

先序遍历DLR：根节点->左子树->右子树

中序遍历LDR：左子树->根节点->右子树。必须要有中序遍历才能得到一棵二叉树的正确顺序

后续遍历LRD：左子树->右子树->根节点。需要栈的支持。

层次遍历：用一维数组存储二叉树时,总是以层次遍历的顺序存储结点。层次遍历应该借助队列。

线索二叉树：对二叉树所有结点做某种处理可在遍历过程中实现；检索（查找）二叉树某个结点，可通过遍历实现；如果能将二叉树线索化，就可以简化遍历算法，提高遍历速度，目的是加快查找结点的前驱或后继的速度。

如何线索化？以中序遍历为例，若能将中序序列中每个结点前趋、后继信息保存起来，以后再遍历二叉树时就可以根据所保存的结点前趋、后继信息对二叉树进行遍历。对于二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点的线索。前驱就是在这一点之前走过的点，不是下一将要去往的点。

加上结点前趋后继信息（结索）的二叉树称为线索二叉树。n个结点的线索二叉树上每个结点有2个指针域（指向左孩子和右孩子），总共有2n个指针域；一个n个结点的树有n-1条边，那么空指针域= 2n - (n-1) = n + 1，即线索数为n+1。指针域tag为0，存放孩子指针，为1，存放前驱/后继节点指针。


## 树和森林

树的存储结构：

* 双亲表示法

* 孩子表示法

* 利用图表示树

* 孩子兄弟表示法（二叉树表示法）：链表中每个结点的两指针域分别指向其第一个孩子结点和下一个兄弟结点


将树转化成二叉树：右子树一定为空

* 加线：在兄弟之间加一连线

* 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系

* 旋转：以树的根结点为轴心，将整树顺时针转45°

森林转换成二叉树：

* 将各棵树分别转换成二叉树

* 将每棵树的根结点用线相连

* 以第一棵树根结点为二叉树的根

树与转换后的二叉树的关系：转换后的二叉树的先序对应树的先序遍历；转换后的二叉树的中序对应树的后序遍历

### 哈弗曼树/霍夫曼树

一些概念

路径：从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径；

路径长度：路径上的分支数目称为路径长度；

树的路径长度：从根到每个结点的路径长度之和。

结点的权：根据应用的需要可以给树的结点赋权值；

结点的带权路径长度：从根到该结点的路径长度与该结点权的乘积；

树的带权路径长度=树中所有叶子结点的带权路径之和；通常记作 WPL=∑w<sub>i</sub>×l<sub>i</sub>

哈夫曼树：假设有n个权值(w<sub>1</sub>, w<sub>2</sub>, … , w<sub>n</sub>)，构造有n个叶子结点的二叉树，每个叶子结点有一个 w<sub>i</sub>作为它的权值。则带权路径长度最小的二叉树称为哈夫曼树。最优二叉树。

前缀码的定义：在一个字符集中，任何一个字符的编码都不是另一个字符编码的前缀。霍夫曼编码就是前缀码，可用于快速判断霍夫曼编码是否正确。霍夫曼树是满二叉树，若有n个节点，则共有(n+1)/2个码子

给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为霍夫曼树(Huffman Tree)。霍夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

假设哈夫曼树是二叉的话，则度为0的结点个数为N，度为2的结点个数为N-1，则结点总数为2N-1。哈夫曼树的结点个数必为奇数。

哈夫曼树不一定是完全二叉树，但一定是最优二叉树。

若度为m的哈夫曼树中,其叶结点个数为n,则非叶结点的个数为[(n-1)/(m-1)]。边的数目等于度。
